%% Preprocessing of the Data

% Setup the environment and load necessary data
load('Data/Atlas_Anatomical/tess_cortex_mid_high_8000V_fix.mat');
load('Data/Avarege_Conn&Tract_ROISpace/averageConnectivity_tractLengths.mat');
load('Data/Avarege_Conn&Tract_ROISpace/averageConnectivity_Fpt.mat');
%load('Data/Model_Parameters/parameters.mat');
load('Data/Average_Velocity_ROISpace/averageDelays_FTRACTS.mat')
load('Data/Average_Velocity_ROISpace/GPfit_Delay_Mean.mat')
%load('DataAverage_Velocity_ROISpace/GPfit_Delay_Mean.mat');
% Align the data with the HCP-MMP1.0 Atlacorrected_delaycorrected_delays generated by Brainstorm
Labels_Atlas = cell(1, 360);
for j = 1:360
    Labels_Atlas{j} = selectBeforeSecondUnderscore(Atlas(iAtlas).Scouts(j).Label);
end

Labels_Tracts = parcelIDs;  
N_roi = length(Labels_Atlas);

%% Correcting the Length of the Tracts Matrix

% Reference: Rosen BQ, Halgren E (2022) An estimation of the absolute number
% of axons indicates that human cortical areas are sparsely connected. PLoS
% Biol 20(3): e3001575. https://doi.org/10.1371/journal.pbio.3001575
disp ("-->> Correcting the Tracts Matrix by the Atlas");
corrected_tractLengths = zeros(N_roi, N_roi);
new_order = [];
for i = 1:360
    target_Atlas_label = Labels_Atlas{i};
    for j = 1:360
        if strcmpi(target_Atlas_label, Labels_Tracts{j})
            new_order = [new_order, j];
        end
    end
end

corrected_tractLengths = tractLengths(new_order, new_order);

%% Correcting the Connectivity Matrix
disp ("-->> Correcting the Connectivity Matrix by the Atlas");
Fpt = exp(Fpt);
Fpt = nulldiag(Fpt);
corrected_conn = Fpt(new_order, new_order);
corrected_conn = corrected_conn/max(max(corrected_conn));
Fpt = Fpt/max(max(Fpt));

%%
Labels_TractsDelay = averageDelays_FTRACTS.parcelIDs;
%%
disp ("-->> Interpolating the Tracts and Connectivity Matrix to high resolution");
HCP_MMP1 = Atlas(iAtlas);
N_voxel = length(Curvature);

%% Correcting the Lead Field

HeadModel = load('Data/Lead_Field/headmodel_surf_openmeeg.mat');
[N_elec,~] = size(HeadModel.Gain);
Cdata = load('Data/Lead_Field/channel_10-20_19.mat');
labels = load('Data/Scalp_Density_Matrix/G5WWO4TYJMYA.mat');
labels = labels.data_struct.dnames;
disp ("-->> Removing Channels  by preprocessed EEG");
[Cdata_r, Gain] = remove_channels_by_preproc_data(labels, Cdata, HeadModel.Gain);
disp ("-->> Sorting Channels and LeadField by preprocessed EEG");
[Cdata_s, Gain] = sort_channels_by_preproc_data(labels, Cdata_r, Gain);

VertNormals= reshape(VertNormals,[1,N_voxel,3]);
VertNormals = repmat(VertNormals,[N_elec,1,1]);
Gain = reshape(Gain,N_elec,3,N_voxel);
Gain = permute(Gain,[1,3,2]);
Gain = sum(Gain.*VertNormals,3);
%% Generating local connectivity structure

disp ("-->> Creating local Connectivity Structure from the Atlas");
% Initialize connectivity matrix W with zeros
conn_local8K = zeros(N_voxel, N_voxel);

% Iterate through each face in the Faces matrix
numFaces = size(Faces, 1);

for f = 1:numFaces
    % Get the indices of the three vertices of the current triangle
    i = Faces(f, 1);
    j = Faces(f, 2);
    k = Faces(f, 3);
    
    % Set W_ij to 1 if i and j belong to the same face (triangle)
    conn_local8K(i, j) = 1;
    conn_local8K(j, i) = 1;
    
    % Set W_ik to 1 if i and k belong to the same face
    conn_local8K(i, k) = 1;
    conn_local8K(k, i) = 1;
    
    % Set W_jk to 1 if j and k belong to the same face
    conn_local8K(j, k) = 1;
    conn_local8K(k, j) = 1;
end


%% Save data

load('Data/Scalp_Density_Matrix/LFMDCR2HNVTQ.mat')
fmax = data_struct.fmax;
parameters.Data.Cross = data_struct.CrossM(:,:,1:49);
parameters.Data.freq = data_struct.freqrange(1:49);

 R  = voxel_roi_map;

parameters.Model.K = Gain*R';
parameters.Model.C = corrected_conn;
%parameters.Model.L = tract_8K;
parameters.Model.D =corrected_delay/1000; % delays in seconds 
parameters.Model.R = R;
parameters.Model.C_local = R*conn_local8K*R';

parameters.Regularization = [10,10,10];
parameters.BayesIter = 30;

parameters.Dimensions.Ne = N_elec;
parameters.Dimensions.Nr = N_roi;
parameters.Dimensions.Nv =N_voxel;

parameters.Dimensions.Nw =  length(parameters.Data.freq);
parameters.Stochastic.stoch = 0;
parameters.Stochastic.Nsfreq =1;
parameters.Stochastic.Niter = 1;
parameters.Parallel.Conn_Delay = 1;
parameters.Parallel.Lambda = 0;
parameters.Parallel.T = 0;
parameters.Parallel.Kmin = 0;
parameters.Parallel.StochFISTA = 0;
parameters = sample_frequencies(parameters);


% Compute the T_operator T = I- Conn*exp(-2 pi i w Delay)
disp ("-->> Compute the T_operator for the inverse model");
parameters = Teval(parameters);

