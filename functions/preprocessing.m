%% Preprocessing of the Data

%     Author: Ronald Garcia, Ariosky Areaces Gonzales, Pedro A. Valdes Sosa 
%     Create Time: 2024 

% Initialize workspace by clearing variables and closing figures
clear all;
close all;

%% Reading Anatomical Data

setup;
disp('--> Reading Anatomical Data')
load('Data/Atlas_Anatomical/tess_cortex_mid_high_8000V_fix.mat');
load('Data/Avarege_Conn&Tract_ROISpace/averageConnectivity_tractLengths.mat');
load('Data/Avarege_Conn&Tract_ROISpace/averageConnectivity_Fpt.mat');
load('Data/Model_Parameters/parameters.mat');
load('Data/Average_Velocity_ROISpace/averageDelays_FTRACTS.mat')

% Align the data with the HCP-MMP1.0 Atlas generated by Brainstorm

Labels_Atlas = cell(1, 360);
for j = 1:360
    Labels_Atlas{j} = selectBeforeSecondUnderscore(Atlas(iAtlas).Scouts(j).Label);
end

Labels_Tracts = parcelIDs;  
Nr = length(Labels_Atlas);

%% Correcting the Length of the Tracts Matrix

% Reference: Rosen BQ, Halgren E (2022) An estimation of the absolute number
% of axons indicates that human cortical areas are sparsely connected. PLoS
% Biol 20(3): e3001575. https://doi.org/10.1371/journal.pbio.3001575

disp ("-->> Correcting the Tracts Lengths by the Atlas");
corrected_tractLengths = zeros(Nr, Nr);
new_order = [];
for i = 1:Nr
    target_Atlas_label = Labels_Atlas{i};
    for j = 1:Nr
        if strcmpi(target_Atlas_label, Labels_Tracts{j})
            new_order = [new_order, j];
        end
    end
end

corrected_tractLengths = tractLengths(new_order, new_order);

%% Correcting the Connectivity Matrix

disp ("-->> Correcting the Anatomical Connectivity by the Atlas");
Fpt = exp(Fpt);
Fpt = nulldiag(Fpt);
corrected_conn = Fpt(new_order, new_order);
corrected_conn = corrected_conn/max(max(corrected_conn));
Fpt = Fpt/max(max(Fpt));

%% Read and Correct Delay Matrix Between Neurotracts

%Lemaréchal JD, Jedynak M, Trebaul L, Boyer A, Tadel F, Bhattacharjee M, 
% Deman P, Tuyisenge V, Ayoubian L, Hugues E, Chanteloup-Forêt B, Saubat C,
% Zouglech R, Reyes Mejia GC, Tourbier S, Hagmann P, Adam C, Barba C, 
% Bartolomei F, Blauwblomme T, Curot J, Dubeau F, Francione S, Garcés M,
% Hirsch E, Landré E, Liu S, Maillard L, Metsähonkala EL, Mindruta I, Nica 
% A, Pail M, Petrescu AM, Rheims S, Rocamora R, Schulze-Bonhage A, Szurhaj 
% W, Taussig D, Valentin A, Wang H, Kahane P, George N, David O; F-TRACT 
% consortium. A brain atlas of axonal and synaptic delays based on modelling 
% of cortico-cortical evoked potentials. Brain. 2022 Jun 3;145(5):1653-1667. 
% doi: 10.1093/brain/awab362. PMID: 35416942; PMCID: PMC9166555.

Labels_TractsDelay = averageDelays_FTRACTS.parcelIDs;
disp ("-->> Correcting the Conduction Delays by the Atlas");
corrected_delay = zeros(Nr, Nr);
delay = averageDelays_FTRACTS.delays;
delay = delay(9:end,:);
new_order = [];
for i = 1:Nr
    target_Atlas_label = Labels_Atlas{i};
    for j = 1:Nr
        if strcmpi(target_Atlas_label, Labels_TractsDelay{j})
            new_order = [new_order, j];
        end
    end
end
corrected_delay= delay(new_order, new_order);
correted_delay = sym_matrix(corrected_delay); 

% Fill the nan entries using gaussian processes regression 
load('Data/Average_Velocity_ROISpace/GPfit_Delay_Mean.mat');
nonnan_corrected_delay=corrected_delay;

%% Visualize the Tract and Connectivity Matrices in the ROI Space

% 
figure(1);
%colormap("hot");
subplot(3, 3, 1);
image(Fpt*1000);
view(2)
title('Original Connectivity Matrix');

subplot(3, 3, 2);
image(tractLengths);
title('Original Tract Lengths Matrix');

subplot(3, 3, 3);
image(delay*10);
title('Original Delay Matrix');

subplot(3, 3, 4);
image(corrected_conn*1000);
title('Corrected Connectivity Matrix');

subplot(3, 3, 5);
image(corrected_tractLengths);
title('Corrected Tract Lengths Matrix');

subplot(3, 3, 6);
image(nonnan_corrected_delay*15);
title('Corrected Delay Matrix');

%% Map the Tract and Connectivity Matrices to the Voxel Space

disp ("-->> Interpolating the Tracts and Connectivity Matrix to high resolution");
HCP_MMP1 = Atlas(iAtlas);
Nv = length(Curvature);
conn_8K = zeros(Nv, Nv);
tract_8K = zeros(Nv, Nv);
delay_8K = zeros(Nv, Nv);
nonnan_delay_8K = zeros(Nv, Nv);

for i = 1:length(tractLengths)
    for j = i+1:length(tractLengths)
        if ~isequal(i, j)
            vertices_i = HCP_MMP1.Scouts(i).Vertices;
            vertices_j = HCP_MMP1.Scouts(j).Vertices;
            conn_8K(vertices_i, vertices_j) = corrected_conn(i, j);
            conn_8K(vertices_j, vertices_i) = corrected_conn(j, i);
            tract_8K(vertices_i, vertices_j) = corrected_tractLengths(i, j);
            tract_8K(vertices_j, vertices_i) = corrected_tractLengths(j, i);
            delay_8K(vertices_i, vertices_j) = nonnan_corrected_delay(i, j);
            delay_8K(vertices_j, vertices_i) = nonnan_corrected_delay(j, i);
            nonnan_delay_8K(vertices_i, vertices_j) = nonnan_corrected_delay(i, j);
            nonnan_delay_8K(vertices_j, vertices_i) = nonnan_corrected_delay(j, i);
        end
    end
end

% Calculate mean of non-zero elements and replace zeros for conn_8K
meanValue_conn = mean(mean(conn_8K(conn_8K ~= 0)));
conn_8K(conn_8K == 0) = meanValue_conn;

%Calculate mean of non-zero elements and replace zeros for tract_8K
meanValue_tract = mean(mean(tract_8K(tract_8K ~= 0)));
tract_8K(tract_8K == 0) = meanValue_tract;

%Calculate mean of non-zero elements and replace zeros for delay_8K
meanValue_delay = mean(mean(delay_8K(delay_8K ~= 0)));
delay_8K(delay_8K == 0) = meanValue_delay;
nonnan_delay_8K(delay_8K==0) = meanValue_delay;

effconn_8K = double(~isnan(delay_8K));
%% Symmetrizing the matrices 

conn_8K = nulldiag(sym_matrix(conn_8K));
tract_8K = nulldiag(sym_matrix(tract_8K));
delay_8K = nulldiag(sym_matrix(delay_8K));


%% Visualize the Tract and Connectivity Matrices in the Voxel Space

subplot(3, 3, 7);
image(conn_8K * 1200);
title('Corrected Connectivity Matrix in Voxel Space');

subplot(3, 3, 8);
image(tract_8K);
title('Corrected Tract Lengths Matrix in Voxel Space');

subplot(3, 3, 9);
image(delay_8K*15);
title('Corrected Delay Matrix in Voxel Space');


%% Correcting the Lead Field

HeadModel = load('Data/Lead_Field/headmodel_surf_openmeeg.mat');
[Ne,~] = size(HeadModel.Gain);
Ne = Ne-1; % Average Reference
Cdata = load('Data/Lead_Field/channel_10-20_19.mat');
labels = load('Data/Lead_Field/labels_scalp.mat');
labels = labels.labels;
disp ("-->> Removing Channels  by preprocessed EEG");
[Cdata_r, Gain] = remove_channels_by_preproc_data(labels, Cdata, HeadModel.Gain);
disp ("-->> Sorting Channels and LeadField by preprocessed EEG");
[Cdata_s, Gain] = sort_channels_by_preproc_data(labels, Cdata_r, Gain);

VertNormals= reshape(VertNormals,[1,Nv,3]);
VertNormals = repmat(VertNormals,[Ne,1,1]);
Gain = reshape(Gain,Ne,3,Nv);
Gain = permute(Gain,[1,3,2]);
Gain = sum(Gain.*VertNormals,3);

%% Generating Local Connectivity Structure

disp ("-->> Creating local Connectivity Structure from the Atlas");
% Initialize connectivity matrix W with zeros
conn_local8K = zeros(Nv, Nv);

% Iterate through each face in the Faces matrix
numFaces = size(Faces, 1);

for f = 1:numFaces
    
    % Get the indices of the three vertices of the current triangle
    i = Faces(f, 1);
    j = Faces(f, 2);
    k = Faces(f, 3);
    
    % Set W_ij to 1 if i and j belong to the same face (triangle)
    conn_local8K(i, j) = 1;
    conn_local8K(j, i) = 1;
    
    % Set W_ik to 1 if i and k belong to the same face
    conn_local8K(i, k) = 1;
    conn_local8K(k, i) = 1;
    
    % Set W_jk to 1 if j and k belong to the same face
    conn_local8K(j, k) = 1;
    conn_local8K(k, j) = 1;

end

%% Average Reference Cross

disp('--> Preforming Average Reference on the Cross-Spectrum')
load('Data/Scalp_Density_Matrix/Control/F5NEYQ3SO5AQ.mat')
% Frequency
Nw = 47;
freq = data_struct.freqrange(1:Nw);

% Cross
Cross = data_struct.CrossM(:,:,1:Nw);
Cross = aveReference(Cross);


%% Save Data

% Cross-Spectrum Data
parameters.Data.Cross = Cross; % Cross-Spectrum
parameters.Data.freq = freq;   % Frequency range
R  = voxel_roi_map;
E = roi_voxel_map;

% Full Model of Spatio - Temporal Correlation on the Voxel Space
parameters.Model.K = Gain;    % Lead Field
parameters.Model.C =  0.02*conn_8K; % Anatomical Conenctivity
parameters.Model.L = tract_8K; % Length of the tracts
parameters.Model.D = delay_8K/1000; % delays in seconds 
parameters.Model.R = R;  % Projection matrix from Voxel to ROI space
parameters.Model.E = E;
parameters.Model.C_local =conn_local8K;  % Local Connectivity Structure

% Compress Model  of Spatio - Temporal Correlations on the ROI Space
parameters.Compact_Model.K = Gain*R';    % Lead Field
parameters.Compact_Model.C = 0.02*corrected_conn;  %  Anatomical Connectivity
parameters.Compact_Model.L = corrected_tractLengths; % Length of the Neurotracts
parameters.Compact_Model.D =corrected_delay/1000; % delays in seconds 
parameters.Compact_Model.R = R; 
parameters.Compact_Model.E = E;
parameters.Compact_Model.C_local = R*conn_local8K*R';

% Regularization Parameters
parameters.Regularization = [100,1000,1000]; % Basic Regularization Space
parameters.BayesIter = 30;   % Number of Step 4 Bayesian Optimization

% Model Dimensions
parameters.Dimensions.Ne = Ne;  % Number of electrodes 
parameters.Dimensions.Nr = Nr;  % Number of ROI's
parameters.Dimensions.Nv =Nv;   % Number of Voxels
parameters.Dimensions.Nw =  length(parameters.Data.freq); % Number of frequencies

% Creating Stuctrue 4 Stochastic - FISTA
parameters.Stochastic.stoch = 0;  % Turn off Stoch Mode
parameters.Stochastic.Nsfreq =1;  
parameters.Stochastic.Niter = 1;

% Creating Structure 4 Parallel Computing
parameters.Parallel.Conn_Delay = 0; % Set 1 to enable Parallel Computing
parameters.Parallel.Lambda = 0;
parameters.Parallel.T = 0;
parameters.Parallel.Kmin = 0;
parameters.Parallel.StochFISTA = 0;

parameters = sample_frequencies(parameters);


filePath = 'Data/Model_Parameters/parameters.mat';
save(filePath,"parameters",'-v7.3');


%% Delete Data
disp ("-->> Delete unnecesary data");

clear all 

% Compute the T_operator T = I- Conn*exp(-2 pi i w Delay)
disp ("-->> Compute the Transfer Function of Model (May take some time)");

load('Data/Model_Parameters/parameters.mat');
tic
parameters.Parallel.T = 1;
parameters = Teval(parameters);
toc
filePath = 'Data/Model_Parameters/parameters.mat';
save(filePath,"parameters",'-v7.3');
clear all 



