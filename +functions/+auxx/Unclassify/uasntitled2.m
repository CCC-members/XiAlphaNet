%%

V = zeros(360,360,length(bestVs));
for j=1:length(bestVs)
       vv=mean(cell2mat(bestVs(j)),1);
    V(:,:,j) = v2m(vv);
end


%% Correcting the Length of the Tracts Matrix

load('Data/Atlas_Anatomical/tess_cortex_mid_high_8000V_fix.mat');
load('Data/Avarege_Conn&Tract_ROISpace/averageConnectivity_tractLengths.mat');
load('Data/Avarege_Conn&Tract_ROISpace/averageConnectivity_Fpt.mat');
%load('Data\Model_Parameters\parameters.mat');
load('Data/Average_Velocity_ROISpace/averageDelays_FTRACTS.mat')
% Align the data with the HCP-MMP1.0 Atlas generated by Brainstorm
Labels_Atlas = cell(1, 360);
for j = 1:360
    Labels_Atlas{j} = selectBeforeSecondUnderscore(Atlas(iAtlas).Scouts(j).Label);
end

Labels_Tracts = parcelIDs;  
N = length(Labels_Atlas);

% Reference: Rosen BQ, Halgren E (2022) An estimation of the absolute number
% of axons indicates that human cortical areas are sparsely connected. PLoS
% Biol 20(3): e3001575. https://doi.org/10.1371/journal.pbio.3001575
disp ("-->> Correcting the Tracts Matrix by the Atlas");
corrected_tractLengths = zeros(N, N);
new_order = [];
for i = 1:360
    target_Atlas_label = Labels_Atlas{i};
    for j = 1:360
        if strcmpi(target_Atlas_label, Labels_Tracts{j})
            new_order = [new_order, j];
        end
    end
end

corrected_tractLengths = tractLengths(new_order, new_order);

%%
% Initialize ages and filter to include only those less than 70
% Initialize ages and filter to include only those less than 70
L = corrected_tractLengths;
ages = linspace(10, 100, 200);
age_filter = ages < 70;
ages_filtered = ages(age_filter);


% Initialize mV to store the median delay at each age
% Initialize the result vector
mV = zeros(length(ages_filtered), 1);

% Set the variance for the Gaussian weighting (you can adjust this value)
sigma = mean(L(:));  % Choose an appropriate value for sigma

% Loop over each filtered age
for idx = 1:length(ages_filtered)
    k = idx; % Index corresponding to the age
    
    % Extract the data for the current age
    V_k = V(:,:,k);
    L_k = L; % Length matrix remains the same for all ages
    
    % Flatten the matrices into vectors
    V_k = V_k(:);
    L_k = L_k(:);
    
    % Remove entries where V_k is NaN or Inf
    valid_idx = ~isnan(V_k) & ~isinf(V_k);
    V_k = V_k(valid_idx);
    L_k = L_k(valid_idx);
    
    % **Handle zero lengths to avoid division by zero**
    nonzero_idx = L_k ~= 0;
    V_k = V_k(nonzero_idx);
    L_k = L_k(nonzero_idx);
    
    % Compute the Gaussian-weighted average delay
    weights =exp(-L_k.^2 / (2 * sigma^2));
    numerator = sum(V_k .* weights);
    denominator = sum(weights);
    mV(idx) = numerator / denominator;
end



% Fit a polynomial (degree 4) to the median delays
[p, S] = polyfit(ages_filtered, mV, 4);

% Generate fitted values and standard errors
[mV_fit, delta] = polyval(p, ages_filtered, S);

% Ensure variables are column vectors
ages_filtered = ages_filtered(:);
mV_fit = mV_fit(:);
delta = delta(:);

% Compute the 95% confidence interval (approximately ±2 standard errors)
x_conf_95 = [ages_filtered; flipud(ages_filtered)];
y_conf_95 = [mV_fit + 2*delta; flipud(mV_fit - 2*delta)];

% Compute the 90% confidence interval (approximately ±1.645 standard errors)
z_score_90 = 1.645; % z-score for 90% confidence interval
x_conf_90 = [ages_filtered; flipud(ages_filtered)];
y_conf_90 = [mV_fit + z_score_90*delta; flipud(mV_fit - z_score_90*delta)];

% Plotting the median delays and the fitted polynomial with confidence intervals
figure;
hold on;

% Define colors
colors = [0.2 0.6 0.8;   % Color for eLORETA (used for 95% confidence interval)
          0.8 0.4 0.2;   % Color for LCMV (used for 90% confidence interval)
          0.6 0.8 0.2];  % Color for XA (used for the polynomial fit)

% Plot the 95% confidence interval as a shaded area
fill(x_conf_95, y_conf_95, colors(1,:), 'EdgeColor', 'none', 'FaceAlpha', 0.5, 'DisplayName', '95% Confidence Interval');
% Color from eLORETA (light blue for the 95% confidence interval)

% Plot the 90% confidence interval as a shaded area
fill(x_conf_90, y_conf_90, colors(2,:), 'EdgeColor', 'none', 'FaceAlpha', 0.5, 'DisplayName', '90% Confidence Interval');
% Color from LCMV (orange for the 90% confidence interval)

% Plot the fitted polynomial (interpolation line)
plot(ages_filtered, mV_fit, '--', 'Color', colors(3,:), 'LineWidth', 2, 'DisplayName', 'Polynomial Fit (Degree 4)');
% Color from XA (green for the polynomial fit)

% Plot the median delays as data points
plot(ages_filtered, mV, 'o', 'MarkerSize', 4, 'MarkerFaceColor', [1, 0.5, 0], 'MarkerEdgeColor', 'red', 'DisplayName', 'Median Delays');
% Data points with orange fill and red edges

% Set axes labels, title, and limits
xlabel('Age (Years)', 'FontSize', 14, 'FontWeight', 'bold');
ylabel('Median Delay (ms)', 'FontSize', 14, 'FontWeight', 'bold');
title('Polynomial Fitting of Median Delays vs. Age with Confidence Intervals', 'FontSize', 18, 'FontWeight', 'bold');
xlim([min(ages_filtered), max(ages_filtered)]);
grid on;

% Add a legend
legend('Location', 'Best', 'FontSize', 12, 'FontWeight', 'bold');

% Set the axes background color to white
set(gca, 'Color', [1, 1, 1]); % White background

hold off;




%%


% % Initialize storage for v and tract length vectors
ages = linspace(10, 100, 200);

% Filter the age values to include only those less than 70
age_filter = ages < 70;
ages_filtered = ages(age_filter);

% Initialize storage for v and tract length vectors
v_vectors = [];
tract_length_vectors = [];
age_vectors = [];

for j = 1:length(ages_filtered)
    % Convert the matrix V(:,:,j) to a vector
    v_vec = m2v(V(:,:,j));

    % Convert the corrected_tractLengths matrix to a vector (same for all ages)
    tract_length_vec = m2v(corrected_tractLengths);

    % Store the results in the vectors
    v_vectors = [v_vectors; v_vec];
    tract_length_vectors = [tract_length_vectors; tract_length_vec];
    age_vectors = [age_vectors; repmat(ages_filtered(j), length(v_vec), 1)];
end

% Prepare the data for polynomial regression of degree 4
% Create polynomial features (including interaction and higher degree terms)
X = [age_vectors, tract_length_vectors, ...
     age_vectors.^2, tract_length_vectors.^2, age_vectors.*tract_length_vectors, ...
     age_vectors.^3, tract_length_vectors.^3, age_vectors.^2 .* tract_length_vectors, age_vectors .* tract_length_vectors.^2, ...
     age_vectors.^4, tract_length_vectors.^4, age_vectors.^3 .* tract_length_vectors, age_vectors.^2 .* tract_length_vectors.^2, age_vectors .* tract_length_vectors.^3];

% Perform the regression
mdl = fitlm(X, v_vectors);

% Generate grid data for plotting
[AgeGrid, TractLengthGrid] = meshgrid(linspace(min(age_vectors), max(age_vectors), 50), ...
                                      linspace(min(tract_length_vectors), max(tract_length_vectors), 50));

% Create the same polynomial features for the grid
X_grid = [AgeGrid(:), TractLengthGrid(:), ...
          AgeGrid(:).^2, TractLengthGrid(:).^2, AgeGrid(:).*TractLengthGrid(:), ...
          AgeGrid(:).^3, TractLengthGrid(:).^3, AgeGrid(:).^2 .* TractLengthGrid(:), AgeGrid(:) .* TractLengthGrid(:).^2, ...
          AgeGrid(:).^4, TractLengthGrid(:).^4, AgeGrid(:).^3 .* TractLengthGrid(:), AgeGrid(:).^2 .* TractLengthGrid(:).^2, AgeGrid(:) .* TractLengthGrid(:).^3];

% Predict the response on the grid
Z = reshape(predict(mdl, X_grid), size(AgeGrid));

% Plotting the surf
figure;
surf(AgeGrid, TractLengthGrid, Z,'EdgeColor','none');
xlabel('Age (Years)');
ylabel('Tract Length (mm)');
zlabel('Regressed Delay (ms)');
title('4th Degree Polynomial Regression: Delay ~ Age + Tract Length');
xlim([min(ages_filtered), max(ages_filtered)]);
%Initialize ages and filter to include only those less than 70




%%ages = linspace(10, 100, 200);
age_filter = ages < 70;
ages_filtered = ages(age_filter);

% Initialize storage for v and age vectors
v_vectors = [];
age_vectors = [];

for j = 1:length(ages_filtered)
    % Convert the matrix V(:,:,j) to a vector
    v_vec = m2v(V(:,:,j));
    
    % Store the results in the vectors
    v_vectors = [v_vectors; v_vec];
    age_vectors = [age_vectors; repmat(ages_filtered(j), length(v_vec), 1)];
end

% Prepare the data for polynomial regression of degree 4
X = [age_vectors, age_vectors.^2, age_vectors.^3, age_vectors.^4];

% Perform the regression
mdl = fitlm(X, v_vectors);

% Generate age grid data for plotting
AgeGrid = linspace(min(age_vectors), max(age_vectors), 100)';

% Create the same polynomial features for the grid
X_grid = [AgeGrid, AgeGrid.^2, AgeGrid.^3, AgeGrid.^4];

% Predict the response on the grid
Y_pred = predict(mdl, X_grid);

% Plotting the regression line
figure;
plot(AgeGrid, Y_pred, 'LineWidth', 2);
xlabel('Age (Years)');
ylabel('Regressed Delay (ms)');
title('4th Degree Polynomial Regression: Delay ~ Age');
xlim([min(ages_filtered), max(ages_filtered)]);

% Optionally, plot the data points
hold on;
scatter(age_vectors, v_vectors, 10, 'filled');
legend('Regression Line', 'Data Points');
hold off;

