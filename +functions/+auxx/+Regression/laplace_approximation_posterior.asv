%% Population spectral net
clc;
clear all;

% Import required helper functions
import functions.auxx.ModelVectorization.*
import guide.Visualization.*
import functions.auxx.ZeroInflatedModels.*
import functions.auxx.Refine_Solution.*
import functions.auxx.OptimizedOperations.*

% Define parameters for analysis
prc = 90;             % Percentile threshold (e.g., for visualizing distributions)
cross_index = 0;      % Cross-validation index (0 = not using CV)
num_groups = 1;       % Number of age groups (for age stratification)
mode = 1;             % 0 = amplitude plots, 1 = zero-inflation probability plots
age_min = 5;          % Minimum age for inclusion
age_max = 100;        % Maximum age for inclusion
Nw = 47;
% Path to the JSON file with model result metadata. Modify this directions
% manually acording to the location of the downloaded data
json_path = 'D:\OneDrive - CCLAB\New_Data_XiAlphaNET\xialphanet_newresults22\XIALPHANET.json';
dir_data = 'D:\OneDrive - CCLAB\New_Data_XiAlphaNET\HarMNqEEG_norms\MultinationalNorms';

% Automatically determine base directory from JSON file path
[dataset_dir, ~, ~] = fileparts(json_path);

% Load and decode dataset JSON
dataset = jsondecode(fileread(json_path));

% Set the location field automatically based on JSON file directory
dataset.Location = dataset_dir;

% Load structural model parameters
parameters = load(fullfile(dataset_dir, 'structural', 'parameters.mat'));
% Set up simulation parameters
Ne = parameters.Dimensions.Ne;  % Number of electrodes
Nr = parameters.Dimensions.Nr;  % Number of ROIs
Nv = parameters.Dimensions.Nr;  % Set voxel to ROI
Nw = parameters.Dimensions.Nw;  % Number of frequency bins
parameters.Dimensions.Nv = Nr;

% Set data dir
subject_folders = dir(fullfile(dir_data, '*'));
subject_folders = subject_folders([subject_folders.isdir] & ~startsWith({subject_folders.name}, '.'));
selected_folders = subject_folders(randperm(length(subject_folders), 1));
subject_folder = selected_folders(1).name;
mat_file_path = fullfile(dir_data, subject_folder, [subject_folder, '.mat']);
data_struct = load(mat_file_path);
freq = data_struct.data_struct.freqrange(1:Nw);
parameters.Data.freq = freq;
parameters.Parallel.T =0;

%%
%% Load template cortex and ROI projection matrix
import templates.*
import guide.functions.split_hemisphere
import guide.functions.tess_smooth
import guide.functions.tess_hemisplit

Cortex   = load("templates/Cortex.mat");
template = load("templates/axes.mat");
currentAxes = template.axes;
hemis = [];
[Cortex, iHideVert] = split_hemisphere(Cortex, hemis);

% ROI projection matrix (Nv × 360)
[R,R_inv] = functions.auxx.ModelVectorization.roi_average_operators(Cortex,14);
%%

import functions.auxx.TOperator.*
import functions.auxx.StochasticEval.*
import functions.auxx.Regularization.*

n = length(dataset.Participants);
All_Data_tmp = cell(1, n);  % combine both x and age
ages_tmp = nan(1, n);       % to filter valid ages later



parfor i = 1:n
    i
    participant = dataset.Participants(i);
    participant_age = participant.Age;

    if isequal(participant.Status, 'Completed') && ...
            age_min <= participant_age && participant_age <= age_max

        try
            % Load JSON metadata
            Part_Info = jsondecode(fileread(fullfile(dataset.Location, participant.SubID, participant.FileInfo)));

            % Load required matrices
            Conn_Matrix = load(fullfile(dataset.Location, participant.SubID, Part_Info.Conn_Matrix));
            Delay_Matrix = load(fullfile(dataset.Location, participant.SubID, Part_Info.Delay_Matrix));
            parameters_i = parameters;
            parameters_i.Compact_Model.C = Conn_Matrix.Conn_Matrix;
            parameters_i.Compact_Model.D = Delay_Matrix.Delay_Matrix;
            [T, ~] = Teval(parameters_i);
            DataCross = load(fullfile(dataset.Location, participant.SubID, Part_Info.Data));
            Sw = DataCross.Cross;
            [nsf_band,sw,sp] = sample_frequencies(freq,0,size(Sw,3));

            % Alpha component
            alpha_process = load(fullfile(dataset.Location, participant.SubID, Part_Info.Alpha_estimate));
            a = zeros(length(alpha_process.Power), 4);
            a(:,1) = alpha_process.Power;
            ta = set_threshold_em(a(:,1));
            a(:,1) = a(:,1) .* (a(:,1) > ta);
            a(:,2) = alpha_process.Width;
            a(:,3) = alpha_process.Exponent;
            a(:,4) = alpha_process.PAF;
            ta = set_threshold_em(a(:,1));
            a(:,1) = a(:,1) .* (a(:,1) > ta);

            % Xi component
            xi_process = load(fullfile(dataset.Location, participant.SubID, Part_Info.Xi_estimate));
            e = zeros(length(xi_process.Power), 3);
            e(:,1) = xi_process.Power;
            e(:,2) = xi_process.Width;
            e(:,3) = xi_process.Exponent;
            te = set_threshold_em(e(:,1));
            e(:,1) = e(:,1) .* (e(:,1) > te);

            % Map voxel to roi
            eR = zeros(size(R,1),3);
            aR = zeros(size(R,1),4);

            eR(:,1)  = R * e(:,1);
            eR(:,2)  = R * e(:,2);
            eR(:,3)  = R * e(:,3);

            aR(:,1)  = R * a(:,1);
            aR(:,2)  = R * a(:,2);
            aR(:,3)  = R * a(:,3);
            aR(:,4)  = R * a(:,4);

            % Build the combined feature
            x = v2x(eR, aR, 1);

            % Fisher
            I_F = functions.auxx.Regression.evaluateFisher(x,Ne,Nv,T,sw,sp,nsf_band,Sw);
            Sigma = regularization(inv(regularization(I_F) + 10^(-6)*eye(size(I_F))));
            snr = sqrt((x.^2)./diag(Sigma));
            
            % Assign single cell entry
            All_Data_tmp{i} = {snr,x, participant_age};
            ages_tmp(i) = participant_age;

        catch ME
            warning("Participant %s failed: %s", participant.SubID, ME.message);
        end
    end
end

%% Post-processing to unpack All_Data
valid = ~cellfun(@isempty, All_Data_tmp);
All_Data = cell(2, sum(valid));
All_Data(1,:) = cellfun(@(c) c{1}, All_Data_tmp(valid), 'UniformOutput', false);
All_Data(2,:) = cellfun(@(c) c{2}, All_Data_tmp(valid), 'UniformOutput', false);
ages = ages_tmp(valid);



%% ============================================================
% Build metric_results from SNR using x2v
% ============================================================

%% ============================================================
% Build metric_results from SNR using x2v (MEAN-BASED)
% ============================================================

Nr = 14;                     % Yeo-7 × L/R
Ns = size(All_Data,2);       % number of subjects

[R_yeo,R_inv_yeo] = functions.auxx.ModelVectorization.roi_average_operators(Cortex,10);
metric_name = 'Wald Stat (dB)';
clim = [0 Inf];               % adjust to your data range

B     = 2000;                % bootstrap samples
alpha = 0.01;                % CI level
nperm = 5000;                % permutations

% ============================================================
% Stack SNR vectors
% ============================================================

SNR_all = cell(1,Ns);
for s = 1:Ns
    SNR_all{s} = All_Data{1,s};
end

% ============================================================
% Convert SNR vectors → parameter tensors using x2v
% ============================================================

A = zeros(Nr,4,Ns);   % Alpha parameters: Power, Width, Exponent, PAF
E = zeros(Nr,3,Ns);   % Xi parameters: Power, Width, Exponent

R_map = R_yeo * R_inv;
R_map = R_map / norm(R_map,'fro');

for s = 1:Ns
    [e,a,~] = x2v(SNR_all{s}.^2);
    for p = 1:4
        if p < 4
            A(:,p,s) = R_map * a(:,p);
            E(:,p,s) = R_map * e(:,p);
        else
            A(:,p,s) = R_map * a(:,p);
        end
    end
end

% ============================================================
% Alpha parameters (MEAN)
% ============================================================

alpha_names = {'Alpha_Power','Alpha_Width','Alpha_Exponent','Alpha_PAF'};

for p = 1:4

    X = squeeze(A(:,p,:))';    % [Ns × Nr]

    ROIvals = mean(X,1,'omitnan')';

    CI_l = zeros(Nr,1);
    CI_u = zeros(Nr,1);
    for r = 1:Nr
        bootstat = bootstrp(B,@mean,X(:,r));
        CI_l(r) = prctile(bootstat,100*alpha/2);
        CI_u(r) = prctile(bootstat,100*(1-alpha/2));
    end

    pvals = zeros(Nr,1);
    for r = 1:Nr
        obs = mean(X(:,r),'omitnan');
        perm = zeros(nperm,1);
        for k = 1:nperm
            perm(k) = mean(X(:,r).*sign(randn(Ns,1)),'omitnan');
        end
        pvals(r) = mean(abs(perm) >= abs(obs));
    end

    [~,~,~,qvals] = fdr_bh(pvals,0.05);

    metric_results.(alpha_names{p}).ROIvals  = ROIvals;
    metric_results.(alpha_names{p}).CI_lower = CI_l;
    metric_results.(alpha_names{p}).CI_upper = CI_u;
    metric_results.(alpha_names{p}).qvals    = qvals;
end

% ============================================================
% Xi parameters (MEAN)
% ============================================================

xi_names = {'Xi_Power','Xi_Width','Xi_Exponent'};

for p = 1:3

    X = squeeze(E(:,p,:))';    % [Ns × Nr]

    ROIvals = mean(X,1,'omitnan')';

    CI_l = zeros(Nr,1);
    CI_u = zeros(Nr,1);
    for r = 1:Nr
        bootstat = bootstrp(B,@mean,X(:,r));
        CI_l(r) = prctile(bootstat,100*alpha/2);
        CI_u(r) = prctile(bootstat,100*(1-alpha/2));
    end

    pvals = zeros(Nr,1);
    for r = 1:Nr
        obs = mean(X(:,r),'omitnan');
        perm = zeros(nperm,1);
        for k = 1:nperm
            perm(k) = mean(X(:,r).*sign(randn(Ns,1)),'omitnan');
        end
        pvals(r) = mean(abs(perm) >= abs(obs));
    end

    [~,~,~,qvals] = fdr_bh(pvals,0.05);

    metric_results.(xi_names{p}).ROIvals  = ROIvals;
    metric_results.(xi_names{p}).CI_lower = CI_l;
    metric_results.(xi_names{p}).CI_upper = CI_u;
    metric_results.(xi_names{p}).qvals    = qvals;
end

% ============================================================
% Final plot
% ============================================================

guide.Visualization.plot_metric_combined_figure( ...
    metric_results, R_inv_yeo, metric_name, clim);

% ============================================================
% Helper: FDR Benjamini-Hochberg
% ============================================================

function [h, crit_p, adj_p, qvals] = fdr_bh(pvals,q)

p = pvals(:);
n = sum(~isnan(p));

[p_sorted, sort_ids] = sort(p);
thresh = (1:n)'/n * q;

below = p_sorted <= thresh;
if any(below)
    crit_p = max(p_sorted(below));
else
    crit_p = 0;
end

h = p_sorted <= crit_p;
adj_p = min(1, cummin((n./(1:n)') .* p_sorted,'reverse'));

qvals = nan(size(p));
qvals(sort_ids) = adj_p;
qvals = reshape(qvals,size(pvals));

end
